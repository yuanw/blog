* What and Why
Nix Flakes are a set of experimental features in the Nix package manager.

If you are not familiar with ~Flakes~ yet, here is a list of resources on it.

- [[https://nixos.wiki/wiki/Flakes][Nix Wiki On Flakes]]
- [[https://zimbatm.com/NixFlakes][zimbatm's article on Flakes]]
- Nix Flakes Series on tweag.io by Eelco himself
  + [[https://www.tweag.io/blog/2020-05-25-flakes/][Part I]]
  + [[https://www.tweag.io/blog/2020-06-25-eval-cache/][Part II]]
  + [[https://www.tweag.io/blog/2020-07-31-nixos-flakes/][Part III]]
- [[https://www.youtube.com/watch?v=UeBX7Ide5a0][NixCon 2019 Nix Flakes - Eelco Dolstra]]
- [[https://www.youtube.com/watch?v=QXUlhnhuRX4&list=PLgknCdxP89RcGPTjngfNR9WmBgvD_xW0l][Jörg Thalheim Nix Flakes 101]]

  the rest of this article is basically a rehash these listed contents.

Some of goals of Flakes are
- Standardized how we compose ~nix~ files and provide a single entry-point
  (no more ~ci.nix~, ~shell.nix~)

- Standardized nix packages' dependency management
  (no more niv)
- a set of more user friendly nix commands
- better reproducibility

* How to install/uninstall Flakes
** install
Right now, Nix Flakes is not enabled by default. We
need to explicitly enable it.
*** NixOS
adding the following in the ~configuration.nix~

#+begin_src nix
{ pkgs, ... }: {
  nix = {
    package = pkgs.nixFlakes;
    extraOptions = ''
      experimental-features = nix-command flakes
    '';
  };
}
#+end_src
*** non-NixOS
#+begin_src shell
nix-env -iA nixpkgs.nixFlakes
#+end_src
and add

#+begin_src shell
experimental-features = nix-command flakes
#+end_src

to ~~/.config/nix/nix.conf~ (if current shell user is nix trusted users) or ~/etc/nix/nix.conf~

Install Nix Flakes installer
I am not sure whether this step is still needed
#+begin_src shell
sh <(curl -L https://github.com/numtide/nix-flakes-installer/releases/download/nix-2.4pre20210126_f15f0b8/install)
#+end_src

You can type ~nix-env --version~ to verify.
The Flakes version should looks like ~nix-env (Nix) 2.4pre20210126_f15f0b8~. (the version was 3.0, and version rollbacked to 2.4)

** uninstall
*** NixOS
just revert the change in ~configuration.nix~ and do ~nixos-rebuild switch~
*** non-NixOS
~nix-env -iA nixpkgs.nix~ should bring out ~nix~ to the mainline version, and we need to revert the ~nix.conf~ change.
Of course, multi-user version needs to restart ~nix-daemon~.

* How to bootstrap a Nix Flakes project
use ~nix flake init~ to generate the ~flake.nix~,
~nix flake update~ to generate ~flake.lock~ file.

An important thing about Flakes, to improve the reproducibility, Flakes requires us to git staging all the ~flake.nix~ changes.
* (Selective) Anatomy of ~flake.nix~
Beside ~description~, ~flake.nix~ has 2 top-level attributes

- ~inputs~ (the dependency management part)
- ~outputs~ the function takes the all inputs we defined and evaluate a set of attributes. (Usually our build artifacts).

** inputs
a typical input might look like
#+begin_src nix
{
  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs/nixpkgs-unstable";
    flake-utils.url = "github:numtide/flake-utils/master";
  };
}
#+end_src
here, it declares two dependencies ~nixpkgs~ and ~flake-utils~. We can use ~nix flake update~ to lock down dependencies.

We can point to a branch: ~inputs.nixpkgs.url = "github:Mic92/nixpkgs/master";~.

or revision: ~inputs.nix-doom-emacs.url = "github:vlaci/nix-doom-emacs?rev=238b18d7b2c8239f676358634bfb32693d3706f3";~

for non-Flakes dependency, we need to declare that.
#+begin_src nix
{
  inputs.bar.url = "github:foo/bar/branch";
  inputs.bar.flake = false;
}
#+end_src
Further, we can override a Flake dependency's input
#+begin_src nix
{
  inputs.sops-nix.url = "github:Mic92/sops-nix";
  inputs.sops-nix.inputs.nixpkgs.follows = "nixpkgs";
}
#+end_src
** outputs
*** Schema
I skipped all the ~nixos~ related attributes.

#+begin_src
{ self, ... }@inputs:
{
  # Executed by `nix flake check`
  checks."<system>"."<attr>" = derivation;
  # Executed by `nix build .#<name>`
  packages."<system>"."<attr>" = derivation;
  # Executed by `nix build .`
  defaultPackage."<system>" = derivation;
  # Executed by `nix run .#<name>`
  apps."<system>"."<attr>" = {
    type = "app";
    program = "<store-path>";
  };
  # Executed by `nix run . -- <args?>`
  defaultApp."<system>" = { type = "app"; program = "..."; };
}
#+end_src
where
- ~<system>~ is the name of the platform, such as "x86_64-linux", "x86_64-darwin"
- ~<attr>~ is the attribute name (package name)
- ~<store-path>~ is a ~/nix/store...~ path

So for each ~<attr>~, we can have

  - check (prerequisites for build the package)
  - package
  - app (executable)

and we can define a default ~<attr>~.
**  [[https://github.com/numtide/flake-utils][flake-utils]]
~flake-utils~ ,as its name indicates, is a utility package help us write flake.

For example, it has [[https://github.com/numtide/flake-utils/blob/3982c9903e93927c2164caa727cd3f6a0e6d14cc/default.nix#L60][~eachDefaultSystem~]] function take a lambda and iterate through all the systems supported by nixpkgs an hydra. So we can reuse the same lambda to build for different systems.

~flattenTree~ takes a tree of attributes and flatten them into a one level key-value (attribute to derivation), which is what Flakes packages outputs expects.

~flattenTree { hello = pkgs.hello; gitAndTools = pkgs.gitAndTools }~

returns
#+begin_src
{
  hello = «derivation»;
  "gitAndTools/git" = «derivation»;
  "gitAndTools/hub" = «derivation»;
}
#+end_src

~mkApp~ is a helper function to construct ~nix app~.

here is an example
#+begin_src nix
{
  description = "Flake utils demo";

  inputs.flake-utils.url = "github:numtide/flake-utils";

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let pkgs = nixpkgs.legacyPackages.${system};
      in rec {
        packages = flake-utils.lib.flattenTree {
          hello = pkgs.hello;
          gitAndTools = pkgs.gitAndTools;
        };
        defaultPackage = packages.hello;
        apps.hello = flake-utils.lib.mkApp { drv = packages.hello; };
        defaultApp = apps.hello;
      });
}
#+end_src
* Example: nix-tree
[[https://github.com/utdemir][utdemir]] has this nice and concise [[https://github.com/utdemir/nix-tree/blob/main/flake.nix][example]] using Flakes with a Haskell project. I think it is a great starting point to understand Flakes.

in ~nix-tree~, the outputs looks likes
#+begin_src nix
 {
   outputs = { self, nixpkgs, flake-utils }: # list out the dependencies
     let
       overlay = self: super: { # a pattern of bring build artifacts to pkgs
         haskellPackages = super.haskellPackages.override {
           overrides = hself: hsuper: {
             nix-tree = hself.callCabal2nix "nix-tree"
               (self.nix-gitignore.gitignoreSourcePure [
                 ./.gitignore
                 "asciicast.sh"
                 "flake.nix"
               ] ./.) { };
           };
         };
         nix-tree =
           self.haskell.lib.justStaticExecutables self.haskellPackages.nix-tree;
       };
     in {
       inherit overlay;
     } // flake-utils.lib.eachDefaultSystem (system: # leverage flake-utils
       let
         pkgs = import nixpkgs {
           inherit system;
           overlays = [ overlay ];
         };
       in {
         defaultPackage = pkgs.nix-tree;
         devShell = pkgs.haskellPackages.shellFor { # development environment
           packages = p: [ p."nix-tree" ];
           buildInputs = with pkgs.haskellPackages; [
             cabal-install
             ghcid
             ormolu
             hlint
             pkgs.nixpkgs-fmt
           ];
           withHoogle = false;
         };
       });
 }
#+end_src

Let's break down the function a little bit.
The outputs have 2 dependencies ~nixpkgs~ and ~flake-utils~.

First thing, it construct an overlay contains the local ~nix-tree~ as Haskell package and a derivation for the executable.

Next, for ~eachDefaultSystem~, it initialize the new nixpkgs with relevant system and overlay, and construct ~defaultPackage~ and ~devShell~. ~devShell~ is Nix Flakes' version of ~nix-shell~ (without -p capability, if you want to use nix-shell -p, there is ~nix shell~). We can start a development shell by ~nix develop~ command. There is ~nix develop~ [[https://zimbatm.com/NixFlakes/#direnv-integration][integration]] with ~direnv~
