---
title: How to send batch SQL update with spring r2dbc
date: 2024-06-20
draft: true
lastUpdated: 2024-06-20
tags:
  - TIL
  - java
  - r2dbc
---

# How to do a single statement SQL update using r2dbc ?
Probably, the most common way is the following
```java
import org.springframework.r2dbc.core.DatabaseClient;
ConnectionFactory factory = â€¦

 DatabaseClient client = DatabaseClient.create(factory);
 Mono<Map<String, Object>> actor = client.sql("INSERT INTO t_actor (first_name, last_name ) VALUES (:fName, :lName")
 .bind("fName", "First")
 .bind("lNane", "last")
 .fetch().first();
```

With java multi-line support, and `bind` method has common sql-injection protection. This is a reasonable interface to work with.

# Batch Update

Bind the same parm multiple times  `org.springframework.r2dbc.core.DatabaseClient.sql` wouldn't yield a batch update.

Luckily, `DatabaseClient` has [`inConnectionMany`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/r2dbc/core/ConnectionAccessor.html#inConnectionMany(java.util.function.Function)) method 

https://r2dbc.io/spec/1.0.0.RELEASE/api/io/r2dbc/spi/Statement.html

```java
import org.springframework.r2dbc.core.DatabaseClient;
import io.r2dbc.spi.Statement;
import reactor.core.publisher.Flux;

...
DatabaseClient databaseClient;
....
databaseClient.inConnectionMany(connection -> {
   Statement statement = connection.createStatement("INSERT INTO t_actor (first_name, last_name ) VALUES (:fName, :lName"));
    statement.bind("fName", ...)
        .bind("lName", ...);
    statement.add();
    statement.bind("fName", ...)
        .bind("lName", ...);
    return Flux.from(statments.execute());
});
```

## Why not use [Batch](https://r2dbc.io/spec/1.0.0.RELEASE/api/io/r2dbc/spi/Batch.html)

[Batch](https://r2dbc.io/spec/1.0.0.RELEASE/api/io/r2dbc/spi/Batch.html) doesn't support bind. It only can work with string. Unless the batch update only involve constant, which sounds unlikely, sql-injection should be a concern, using Statement should be a safer approach.


java.lang.IllegalStateException: Not all parameter values are provided yet.)

# Transaction
```java
import com.google.common.collect.Streams;
import io.r2dbc.spi.Result;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.IntStream;
import lombok.Builder;
import lombok.NonNull;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import org.springframework.r2dbc.core.DatabaseClient;
import org.springframework.transaction.ReactiveTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.reactive.TransactionalOperator;
import org.springframework.transaction.support.DefaultTransactionDefinition;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;
import reactor.util.function.Tuples;

@Builder
class Test  {

 
    @NonNull DatabaseClient databaseClient;
    @NonNull ReactiveTransactionManager tm;
    @Builder.Default int isolationLevel = TransactionDefinition.ISOLATION_REPEATABLE_READ;
    @Builder.Default int propagationBehavior = TransactionDefinition.PROPAGATION_REQUIRED;
  

 TransactionDefinition getTxnDfn() {
    var txnDfn = new DefaultTransactionDefinition();
    txnDfn.setIsolationLevel(config.isolationLevel);
    txnDfn.setPropagationBehavior(config.propagationBehavior);
    return txnDfn;
  }
  
  Flux<Result> update() {
  databaseClient.inConnectionMany(
                  connection -> {
                    var statments = connection.createStatement(insertSql());
                    events.forEach(
                        event -> {
                          if (event.getT1() > 0) {
                            statments.add();
                          }
                          statments
                              .bind("id", event.getT2().getId())
                              .bind("topic", event.getT2().getTopic())
                              .bind("auxHeaders", event.getT2().getAuxHeaders());

                          if (event.getT2().getPayload() == null) {
                            statments.bindNull("payload", String.class);
                          } else {
                            statments.bind("payload", event.getT2().getPayload());
                          }
                          if (event.getT2().getId() == null) {
                            statments.bindNull("messageKey", String.class);
                          } else {
                            statments.bind("messageKey", event.getT2().getKey());
                          }
                        });
                    Flux<Result> results = Flux.from(statments.execute());

                    if (config.disableOutboxDelete) {
                      return results;
                    } else {
                      var deleteStatements = connection.createStatement(deleteSql());

                      events.forEach(
                          event -> {
                            if (event.getT1() > 0) {
                              deleteStatements.add();
                            }
                            deleteStatements.bind("id", event.getT2().getId());
                          });
                      return results.thenMany(Flux.from(deleteStatements.execute()));
                    }
                  });
  }
 
 }
```
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/r2dbc/core/DatabaseClient.html
